#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <string>
#include <conio.h>
#include <cmath>
#include <regex>
#include <sstream>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");

    // Считываем размеры массивов,
    // который необходимо слить в
    // один отсортированный массив
    int n, m;
    cout << "Введите n = ";
    cin >> n;
    cout << "Введите m = ";
    cin >> m;

    // Динамически выделяем память под
    // хранение массивов размера n и m
    int *arr1 = new int[n];
    int *arr2 = new int[m];

    // Считываем массивы;
    // По условию алгоритма они уже
    // должны быть отсортированы
    cout << "Заполняем arr1 : ";
    for (int i = 0; i < n; i++)
    {
        cin >> arr1[i];
    }
    cout << "Заполняем arr2 : ";
    for (int i = 0; i < m; i++)
    {
        cin >> arr2[i];
    }

    // Динамически выделяем память под
    // хранение массива, полученного
    // слиянием двух исходных, его
    // размер, очевидно, равен n + m
    int *result = new int[n + m];

    // Заведем два индекса, указывающих
    // на первый необработанный элемент
    // первого и второго массивов
    int i = 0, j = 0;

    // И заведем индекс массива-результата,
    // который указывает позицию, которая
    // будет заполнена на текущем шаге
    int index = 0;

    // Будем повторять сравнение элементов
    // массивов a и b до тех пор, пока
    // в каждом из них есть хотя бы один
    // необработанный элемент
    while (i < n && j < m)
    { // В соответствии с тем, текущий элемент
        // какого массива меньше, мы записываем
        // этот элемент в массив-результат и
        // обновляем нужный индекс (i или j)
        if (arr1[i] < arr2[j])
        {
            result[index] = arr1[i];
            i++;
        }
        else
        {
            result[index] = arr2[j];
            j++;
        }
        index++;
    }
    // После выполнения предыдущего цикла
    // все элементы одного из массивов будут
    // обработаны, тогда оставшиеся элементы
    // другого массива нужно просто дописать
    // в массив-результат
    // Заметим, что одно из условий (i < n)
    // или (j < m) будет гарантированно ложно
    while (i < n)
    {
        result[index] = arr1[i];
        index++;
        i++;
    }
    while (j < m)
    {
        result[index] = arr2[j];
        index++;
        j++;
    }
    cout << "Наш массив : ";
    // Выводим отсортированный массив
    for (int k = 0; k < n + m; k++)
    {
        cout << result[k] << ' ';
    }

    delete[] arr1;
    delete[] arr2;
    delete[] result;
    getch();
    return 0;
}